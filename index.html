<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Updated viewport for mobile: prevents zooming and ensures correct scaling -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Rubik's Cube Simulator</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --panel-bg: rgba(255, 255, 255, 0.1);
            --text-color: #ffffff;
            --accent: #4a90e2;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: var(--text-color);
            user-select: none;
            /* Prevent pull-to-refresh on mobile */
            overscroll-behavior: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
            outline: none;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            /* Safe area for iPhone X+ */
            padding-bottom: env(safe-area-inset-bottom);
        }

        header {
            padding: 15px;
            text-align: center;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            pointer-events: auto;
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .controls-area {
            padding: 20px;
            pointer-events: auto;
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            width: 100%;
            justify-content: center;
        }

        .btn {
            background: var(--panel-bg);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            backdrop-filter: blur(5px);
            text-transform: uppercase;
            font-size: 0.9rem;
            touch-action: manipulation; /* Improves touch response */
            flex: 1;
            max-width: 150px;
        }

        .btn:hover {
            background: var(--accent);
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .btn:active {
            transform: translateY(0);
        }

        /* Virtual Keypad for Mobile/Mouse */
        .move-controls {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .move-btn {
            width: 45px;
            height: 45px;
            border-radius: 8px;
            border: none;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.1s;
            touch-action: manipulation;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .move-btn:active {
            background: var(--accent);
            transform: scale(0.95);
        }

        /* Hover only on non-touch devices to prevent sticky hover states */
        @media (hover: hover) {
            .move-btn:hover {
                background: var(--accent);
            }
        }

        .move-btn span {
            pointer-events: none;
        }

        .move-btn.prime {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .instructions {
            position: absolute;
            top: 60px;
            right: 20px;
            background: rgba(0,0,0,0.6);
            padding: 15px;
            border-radius: 8px;
            font-size: 0.85rem;
            max-width: 250px;
            pointer-events: none;
            backdrop-filter: blur(4px);
        }

        .mobile-hint {
            display: none;
            font-size: 0.8rem;
            color: rgba(255,255,255,0.7);
            margin-top: 5px;
        }

        /* Toggle switch for Prime moves */
        .toggle-container {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1rem;
            margin-bottom: 5px;
            background: rgba(0,0,0,0.3);
            padding: 8px 16px;
            border-radius: 20px;
        }

        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: var(--accent);
        }

        /* Mobile Adjustments */
        @media (max-width: 600px) {
            .instructions { 
                display: none; 
            }
            
            .mobile-hint {
                display: block;
                text-align: center;
            }

            .move-controls {
                /* Change to 3x2 grid for larger buttons on phone */
                grid-template-columns: repeat(3, 1fr);
                gap: 12px;
                padding: 15px;
            }

            .move-btn {
                width: 60px; /* Larger touch targets */
                height: 55px;
                font-size: 1.3rem;
            }

            h1 {
                font-size: 1.2rem;
            }
        }

    </style>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <header>
            <h1>Cube Simulator</h1>
            <div class="mobile-hint">Drag to rotate view â€¢ Tap buttons to move</div>
        </header>

        <div class="instructions">
            <strong>Keyboard Shortcuts:</strong><br>
            Faces: F, B, U, D, L, R<br>
            Hold SHIFT for Inverse (Prime)<br>
            Drag background to rotate view
        </div>

        <div class="controls-area">
            
            <div class="toggle-container">
                <label for="prime-toggle">Inverse Moves (Prime)</label>
                <input type="checkbox" id="prime-toggle">
            </div>

            <div class="move-controls">
                <button class="move-btn" onclick="handleUIInput('L')">L</button>
                <button class="move-btn" onclick="handleUIInput('U')">U</button>
                <button class="move-btn" onclick="handleUIInput('R')">R</button>
                
                <button class="move-btn" onclick="handleUIInput('D')">D</button>
                <button class="move-btn" onclick="handleUIInput('F')">F</button>
                <button class="move-btn" onclick="handleUIInput('B')">B</button>
            </div>

            <div class="action-buttons">
                <button class="btn" onclick="scrambleCube()">Scramble</button>
                <button class="btn" onclick="resetCube()">Reset</button>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration ---
        const CUBE_SIZE = 1;
        const SPACING = 0.02; // Gap between cubies
        const TOTAL_SIZE = CUBE_SIZE + SPACING;
        const ANIMATION_SPEED = 0.15; // Radians per frame approx (controlled by time)
        const MOVES = ['L', 'R', 'U', 'D', 'F', 'B'];

        // --- Colors (Standard Scheme) ---
        const COLORS = {
            right: 0xb90000,  // Red
            left: 0xff5900,   // Orange
            top: 0xffffff,    // White
            bottom: 0xffd500, // Yellow
            front: 0x009b48,  // Green
            back: 0x0045ad,   // Blue
            internal: 0x222222 // Black/Dark Grey
        };

        // --- Globals ---
        let scene, camera, renderer, controls;
        let cubies = []; // Array holding the 27 mesh objects
        let isAnimating = false;
        let pivotGroup; // The temporary parent for rotation

        // --- Initialization ---
        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(6, 5, 8);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Controls (Orbit)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enablePan = false;
            controls.minDistance = 4;
            controls.maxDistance = 15;
            // OrbitControls touch adjustments
            controls.rotateSpeed = 0.7; // Slightly slower for better control on touch

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);
            
            const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
            backLight.position.set(-10, -10, -10);
            scene.add(backLight);

            // Create Cube
            createRubiksCube();

            // Pivot Group (helper for rotations)
            pivotGroup = new THREE.Group();
            scene.add(pivotGroup);

            // Events
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);

            // Loop
            animate();
        }

        // --- Cube Logic ---

        function createRubiksCube() {
            // Clear existing
            cubies.forEach(c => scene.remove(c));
            cubies = [];

            const geometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);

            // 3x3x3 Loop
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        
                        // Create materials array for this specific cubie based on position
                        // Order: Right, Left, Top, Bottom, Front, Back
                        const materials = [
                            new THREE.MeshStandardMaterial({ color: x === 1 ? COLORS.right : COLORS.internal, roughness: 0.1, metalness: 0.1 }),
                            new THREE.MeshStandardMaterial({ color: x === -1 ? COLORS.left : COLORS.internal, roughness: 0.1, metalness: 0.1 }),
                            new THREE.MeshStandardMaterial({ color: y === 1 ? COLORS.top : COLORS.internal, roughness: 0.1, metalness: 0.1 }),
                            new THREE.MeshStandardMaterial({ color: y === -1 ? COLORS.bottom : COLORS.internal, roughness: 0.1, metalness: 0.1 }),
                            new THREE.MeshStandardMaterial({ color: z === 1 ? COLORS.front : COLORS.internal, roughness: 0.1, metalness: 0.1 }),
                            new THREE.MeshStandardMaterial({ color: z === -1 ? COLORS.back : COLORS.internal, roughness: 0.1, metalness: 0.1 }),
                        ];

                        const mesh = new THREE.Mesh(geometry, materials);
                        
                        // Position with spacing
                        mesh.position.set(x * TOTAL_SIZE, y * TOTAL_SIZE, z * TOTAL_SIZE);
                        
                        // Initial Logic Coordinates (to track face belonging)
                        mesh.userData = { 
                            isCubie: true,
                            initialPos: new THREE.Vector3(x, y, z) 
                        };

                        // Add bevel aesthetic (black inner box)
                        const edgeGeo = new THREE.BoxGeometry(CUBE_SIZE * 0.96, CUBE_SIZE * 0.96, CUBE_SIZE * 0.96);
                        const edgeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                        const edgeMesh = new THREE.Mesh(edgeGeo, edgeMat);
                        mesh.add(edgeMesh); // Add as child

                        scene.add(mesh);
                        cubies.push(mesh);
                    }
                }
            }
        }

        // --- Move Logic ---

        // Helper to select cubies on a face
        function getCubiesOnFace(axis, val) {
            // Using a small epsilon because floating point math after rotations isn't perfect
            const epsilon = 0.1;
            return cubies.filter(mesh => {
                // Get world position
                const worldPos = new THREE.Vector3();
                mesh.getWorldPosition(worldPos);
                
                if (axis === 'x') return Math.abs(worldPos.x - val * TOTAL_SIZE) < epsilon;
                if (axis === 'y') return Math.abs(worldPos.y - val * TOTAL_SIZE) < epsilon;
                if (axis === 'z') return Math.abs(worldPos.z - val * TOTAL_SIZE) < epsilon;
                return false;
            });
        }

        function rotateLayer(moveType, isPrime = false, animationDuration = 300) {
            if (isAnimating) return Promise.resolve();
            isAnimating = true;

            // Haptic Feedback for Mobile
            if (navigator.vibrate) navigator.vibrate(10);

            return new Promise((resolve) => {
                let axis = 'y';
                let layerVal = 0; // -1, 0, or 1
                let angle = Math.PI / 2 * (isPrime ? 1 : -1);

                // Define Move Semantics
                switch(moveType) {
                    case 'R': axis = 'x'; layerVal = 1; angle *= -1; break; // Right
                    case 'L': axis = 'x'; layerVal = -1; angle *= -1; break; // Left
                    case 'U': axis = 'y'; layerVal = 1; angle *= -1; break; // Up
                    case 'D': axis = 'y'; layerVal = -1; angle *= -1; break; // Down
                    case 'F': axis = 'z'; layerVal = 1; angle *= -1; break; // Front
                    case 'B': axis = 'z'; layerVal = -1; angle *= -1; break; // Back
                }

                // 1. Identify Cubies
                const activeCubies = getCubiesOnFace(axis, layerVal);

                // 2. Attach to Pivot
                // We must reset pivot rotation first
                pivotGroup.rotation.set(0, 0, 0);
                pivotGroup.position.set(0, 0, 0);
                
                // Attach active cubies to the pivot group
                // THREE.Object3D.attach() preserves world transform
                activeCubies.forEach(c => {
                    pivotGroup.attach(c);
                });

                // 3. Animate Pivot
                const startRot = { val: 0 };
                const targetRot = { val: angle };
                const startTime = Date.now();

                function animateStep() {
                    const now = Date.now();
                    const progress = Math.min((now - startTime) / animationDuration, 1);
                    
                    // Ease out cubic
                    const ease = 1 - Math.pow(1 - progress, 3);
                    
                    const currentAngle = targetRot.val * ease;
                    pivotGroup.rotation[axis] = currentAngle;

                    if (progress < 1) {
                        requestAnimationFrame(animateStep);
                    } else {
                        // 4. Cleanup
                        finishRotation();
                    }
                }

                function finishRotation() {
                    pivotGroup.rotation[axis] = angle; // Ensure exact end
                    pivotGroup.updateMatrixWorld();

                    // Detach back to scene
                    activeCubies.forEach(c => {
                        scene.attach(c);
                        
                        // SNAP TO GRID
                        // This is crucial to prevent floating point drift over many moves
                        c.position.x = Math.round(c.position.x / TOTAL_SIZE) * TOTAL_SIZE;
                        c.position.y = Math.round(c.position.y / TOTAL_SIZE) * TOTAL_SIZE;
                        c.position.z = Math.round(c.position.z / TOTAL_SIZE) * TOTAL_SIZE;
                        
                        c.rotation.x = Math.round(c.rotation.x / (Math.PI/2)) * (Math.PI/2);
                        c.rotation.y = Math.round(c.rotation.y / (Math.PI/2)) * (Math.PI/2);
                        c.rotation.z = Math.round(c.rotation.z / (Math.PI/2)) * (Math.PI/2);
                        
                        c.updateMatrix();
                    });

                    pivotGroup.rotation.set(0,0,0);
                    isAnimating = false;
                    resolve();
                }

                animateStep();
            });
        }

        // --- User Interaction ---

        function handleUIInput(move) {
            // Stronger haptic feedback for button press
            if (navigator.vibrate) navigator.vibrate(15);
            const isPrime = document.getElementById('prime-toggle').checked;
            rotateLayer(move, isPrime);
        }

        function onKeyDown(event) {
            const key = event.key.toUpperCase();
            const validKeys = ['L', 'R', 'U', 'D', 'F', 'B'];
            
            if (validKeys.includes(key)) {
                const isPrime = event.shiftKey; // Shift + Key = Prime
                rotateLayer(key, isPrime);
            }
        }

        async function scrambleCube() {
            if (isAnimating) return;
            if (navigator.vibrate) navigator.vibrate(30);
            
            const count = 20;
            const speed = 60; // Faster animation for scramble
            
            for (let i = 0; i < count; i++) {
                const move = MOVES[Math.floor(Math.random() * MOVES.length)];
                const isPrime = Math.random() > 0.5;
                await rotateLayer(move, isPrime, speed);
            }
        }

        function resetCube() {
            if (isAnimating) return;
            if (navigator.vibrate) navigator.vibrate(30);
            // Easiest way to reset is to recreate the cube
            createRubiksCube();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- Start ---
        init();

    </script>
</body>

</html>

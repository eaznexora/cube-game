<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Rubik's Cube - Realtime Solver</title>
    <style>
        :root {
            /* Fallback color if image doesn't load */
            --bg-color: #0d0d15; 
            --panel-bg: rgba(255, 255, 255, 0.1);
            --text-color: #ffffff;
            --accent: #4a90e2;
            --success: #2ecc71;
            --danger: #e74c3c;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: var(--text-color);
            user-select: none;
            overscroll-behavior: none;

            /* --- BACKGROUND IMAGE SETUP --- */
            background-color: var(--bg-color);
            background-image: url('background.png'); /* Name of your image file */
            background-size: cover;          /* Scales image to cover entire screen */
            background-position: center;     /* Centers the image */
            background-repeat: no-repeat;    /* Prevents tiling */
            background-attachment: fixed;    /* Keeps background static when scrolling (if applicable) */
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
            outline: none;
            cursor: default;
        }

        .cursor-grab { cursor: grab !important; }
        .cursor-grabbing { cursor: grabbing !important; }
        .cursor-pointer { cursor: pointer !important; }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding-bottom: env(safe-area-inset-bottom);
        }

        header {
            padding: 15px;
            text-align: center;
            /* Increased gradient opacity slightly for readability against complex backgrounds */
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            pointer-events: auto;
            position: relative;
            z-index: 10;
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }

        .subtitle {
            font-size: 0.85rem;
            opacity: 0.9;
            margin-top: 5px;
            font-weight: normal;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        }

        /* --- Top Left Group (Back Button) --- */
        .top-left-group {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: auto;
            z-index: 20;
        }

        /* Mobile Adjustments: Move button into flow */
        @media (max-width: 768px) {
            .top-left-group {
                position: static;
                margin-top: 15px;
                width: auto;
                display: inline-block;
            }
            
            /* Slightly smaller button on mobile */
            .btn-portfolio {
                font-size: 0.8rem;
                padding: 6px 14px;
            }
        }

        .btn-portfolio {
            background: rgba(74, 144, 226, 0.8);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: bold;
            cursor: pointer;
            text-decoration: none;
            backdrop-filter: blur(4px);
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            display: inline-block;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .btn-portfolio:hover {
            background: var(--accent);
            transform: translateY(-2px);
        }

        /* --- Top Right Group (View Controls) --- */
        .top-right-group {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
            pointer-events: auto;
            z-index: 20;
        }

        /* View Controls (Arrows) */
        .view-controls {
            display: grid;
            grid-template-columns: repeat(3, 30px);
            grid-template-rows: repeat(2, 30px);
            gap: 5px;
            background: rgba(0,0,0,0.4);
            padding: 8px;
            border-radius: 12px;
            backdrop-filter: blur(4px);
        }

        /* Hide view controls arrows on mobile */
        @media (max-width: 768px) {
            .view-controls { display: none; }
        }

        .view-btn {
            width: 30px;
            height: 30px;
            background: rgba(255,255,255,0.15);
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
        }

        .view-btn:active { background: var(--accent); }
        .view-btn-up { grid-column: 2; grid-row: 1; }
        .view-btn-left { grid-column: 1; grid-row: 2; }
        .view-btn-down { grid-column: 2; grid-row: 2; }
        .view-btn-right { grid-column: 3; grid-row: 2; }

        .controls-area {
            padding: 30px;
            pointer-events: auto;
            background: linear-gradient(to top, rgba(0,0,0,0.95), transparent);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            background: var(--panel-bg);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 12px 25px;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            backdrop-filter: blur(5px);
            text-transform: uppercase;
            font-size: 0.9rem;
            touch-action: manipulation;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            min-width: 100px;
        }

        .btn:hover {
            background: var(--accent);
            transform: translateY(-2px);
        }
        .btn:active { transform: translateY(0); }
        
        .btn-solve {
            border-color: var(--success);
            background: rgba(46, 204, 113, 0.2);
        }
        .btn-solve:hover {
            background: var(--success);
        }

        .keyboard-hints {
            display: none;
            font-size: 0.8rem;
            background: rgba(0,0,0,0.6);
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            text-align: center;
            line-height: 1.4;
            backdrop-filter: blur(2px);
        }

        @media (min-width: 768px) {
            .keyboard-hints { display: block; }
        }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TrackballControls.js"></script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        
        <header>
            <h1>Cube Simulator</h1>
            <div class="subtitle">Drag background to tumble • Drag cube to rotate layers</div>
            
            <!-- Portfolio Button (Inside header for correct mobile flow) -->
            <div class="top-left-group">
                <button class="btn-portfolio" onclick="window.location.href='#'">← Back to Portfolio</button>
            </div>
        </header>

        <!-- Top Right: View Controls -->
        <div class="top-right-group">
            <div class="view-controls">
                <button class="view-btn view-btn-up" onclick="adjustView('up')">▲</button>
                <button class="view-btn view-btn-left" onclick="adjustView('left')">◀</button>
                <button class="view-btn view-btn-down" onclick="adjustView('down')">▼</button>
                <button class="view-btn view-btn-right" onclick="adjustView('right')">▶</button>
            </div>
        </div>

        <div class="controls-area">
            <div class="keyboard-hints">
                <strong>Controls</strong><br>
                WASD / Arrow Keys: Tumble View<br>
                Mouse Drag: Rotate Layers (Interactive)
            </div>
            <div class="action-buttons">
                <button class="btn" onclick="scrambleCube()">Scramble</button>
                <button class="btn btn-solve" onclick="autoSolveCube()">Solve</button>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration ---
        const CUBE_SIZE = 1;
        const SPACING = 0.015; 
        const TOTAL_SIZE = CUBE_SIZE + SPACING;
        
        // Colors
        const COLORS = {
            right: 0xb90000,  // Red
            left: 0xff5900,   // Orange
            top: 0xffffff,    // White
            bottom: 0xffd500, // Yellow
            front: 0x009b48,  // Green
            back: 0x0045ad,   // Blue
            internal: 0x222222 
        };

        // --- Globals ---
        let scene, camera, renderer, controls;
        let cubies = [];
        let pivotGroup;
        
        // --- Interaction State ---
        let interactionState = {
            active: false,
            startMouse: new THREE.Vector2(),
            intersect: null,
            axis: null,      
            slice: null,     
            screenAxis: null,
            locked: false,   
            currentAngle: 0
        };
        
        const DRAG_THRESHOLD = 5; 
        let moveHistory = [];
        let isSolving = false;

        let raycaster, mouse;
        const keyState = { w: false, a: false, s: false, d: false, ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false };

        // --- Initialization ---
        function init() {
            scene = new THREE.Scene();
            
            // IMPORTANT: Set scene background to null so CSS background image shows through
            scene.background = null; 

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.5, 100);
            camera.position.set(6, 5, 8);
            camera.lookAt(0, 0, 0);

            // Renderer with alpha: true enables transparency
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            const container = document.getElementById('canvas-container');
            container.appendChild(renderer.domElement);

            // TRACKBALL CONTROLS
            controls = new THREE.TrackballControls(camera, renderer.domElement);
            controls.rotateSpeed = 2.0;
            controls.zoomSpeed = 1.2;
            controls.panSpeed = 0.8;
            controls.noZoom = false;
            controls.noPan = true;
            controls.staticMoving = false;
            controls.dynamicDampingFactor = 0.1;
            
            // Lighting
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dl1 = new THREE.DirectionalLight(0xffffff, 0.8); dl1.position.set(10, 20, 10); scene.add(dl1);
            const dl2 = new THREE.DirectionalLight(0xffffff, 0.4); dl2.position.set(-10, -10, -5); scene.add(dl2);

            pivotGroup = new THREE.Group();
            scene.add(pivotGroup);
            createRubiksCube();

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            window.addEventListener('resize', onWindowResize);
            setupInputListeners();
            setupKeyboardListeners();

            animate();
        }

        function createRubiksCube() {
            cubies.forEach(c => scene.remove(c));
            cubies = [];
            moveHistory = []; 

            const geo = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);

            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        const mats = [
                            new THREE.MeshStandardMaterial({ color: x === 1 ? COLORS.right : COLORS.internal, roughness: 0.2 }),
                            new THREE.MeshStandardMaterial({ color: x === -1 ? COLORS.left : COLORS.internal, roughness: 0.2 }),
                            new THREE.MeshStandardMaterial({ color: y === 1 ? COLORS.top : COLORS.internal, roughness: 0.2 }),
                            new THREE.MeshStandardMaterial({ color: y === -1 ? COLORS.bottom : COLORS.internal, roughness: 0.2 }),
                            new THREE.MeshStandardMaterial({ color: z === 1 ? COLORS.front : COLORS.internal, roughness: 0.2 }),
                            new THREE.MeshStandardMaterial({ color: z === -1 ? COLORS.back : COLORS.internal, roughness: 0.2 }),
                        ];
                        const mesh = new THREE.Mesh(geo, mats);
                        mesh.position.set(x * TOTAL_SIZE, y * TOTAL_SIZE, z * TOTAL_SIZE);
                        mesh.userData = { initialPos: new THREE.Vector3(x, y, z) };
                        
                        const edge = new THREE.Mesh(
                            new THREE.BoxGeometry(CUBE_SIZE * 0.94, CUBE_SIZE * 0.94, CUBE_SIZE * 0.94),
                            new THREE.MeshBasicMaterial({ color: 0x000000 })
                        );
                        mesh.add(edge);
                        scene.add(mesh);
                        cubies.push(mesh);
                    }
                }
            }
        }

        // --- Interaction Logic ---

        function setupInputListeners() {
            const c = renderer.domElement;
            c.addEventListener('mousedown', onDown);
            c.addEventListener('mousemove', onMove);
            window.addEventListener('mouseup', onUp); 

            c.addEventListener('touchstart', onTouchStart, { passive: false });
            c.addEventListener('touchmove', onTouchMove, { passive: false });
            window.addEventListener('touchend', onUp);
        }

        function getClientCoords(e) {
            if (e.touches && e.touches.length > 0) {
                return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
            return { x: e.clientX, y: e.clientY };
        }

        function onDown(e) {
            if (isSolving) return;
            const coords = getClientCoords(e);
            startInteraction(coords.x, coords.y);
        }

        function onTouchStart(e) {
            if (isSolving) return;
            e.preventDefault(); 
            const coords = getClientCoords(e);
            startInteraction(coords.x, coords.y);
        }

        function startInteraction(cx, cy) {
            mouse.x = (cx / window.innerWidth) * 2 - 1;
            mouse.y = -(cy / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cubies);

            if (intersects.length > 0) {
                controls.enabled = false; 
                const hit = intersects[0];
                
                interactionState = {
                    active: true,
                    startMouse: new THREE.Vector2(cx, cy),
                    intersect: hit,
                    axis: null,
                    slice: null,
                    screenAxis: null,
                    locked: false,
                    currentAngle: 0
                };
                
                document.getElementById('canvas-container').className = 'cursor-grabbing';
            } else {
                controls.enabled = true; 
                interactionState.active = false;
            }
        }

        function onMove(e) {
            if (!interactionState.active) {
                updateCursor(e.clientX, e.clientY, e.buttons);
                return;
            }
            const coords = getClientCoords(e);
            handleDrag(coords.x, coords.y);
        }

        function onTouchMove(e) {
            if (!interactionState.active) return;
            e.preventDefault();
            const coords = getClientCoords(e);
            handleDrag(coords.x, coords.y);
        }

        function handleDrag(cx, cy) {
            if (!interactionState.active) return;

            const dx = cx - interactionState.startMouse.x;
            const dy = cy - interactionState.startMouse.y;
            
            if (!interactionState.locked) {
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > DRAG_THRESHOLD) {
                    lockInteractionAxis(dx, dy);
                }
            }
            
            if (interactionState.locked) {
                const dragVec = new THREE.Vector2(dx, dy);
                const projectedMag = dragVec.dot(interactionState.screenAxis);
                
                const sensitivity = 0.005; 
                interactionState.currentAngle = projectedMag * sensitivity;
                
                if (interactionState.axis) {
                    pivotGroup.rotation[interactionState.axis] = interactionState.currentAngle;
                }
            }
        }

        function lockInteractionAxis(dx, dy) {
            const hit = interactionState.intersect;
            const worldNormal = hit.face.normal.clone().transformDirection(hit.object.matrixWorld).round();
            
            const axes = [];
            if (Math.abs(worldNormal.x) > 0.5) axes.push(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,1));
            else if (Math.abs(worldNormal.y) > 0.5) axes.push(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,1));
            else axes.push(new THREE.Vector3(1,0,0), new THREE.Vector3(0,1,0)); 

            const screenVectors = axes.map(axis => {
                const p1 = hit.point.clone();
                const p2 = hit.point.clone().add(axis);
                p1.project(camera);
                p2.project(camera);
                const sv = new THREE.Vector2(p2.x - p1.x, -(p2.y - p1.y)); 
                return { axis3D: axis, screenVec: sv.normalize() };
            });

            const dragDir = new THREE.Vector2(dx, dy).normalize();
            let bestMatch = null;
            let maxDot = -1;

            screenVectors.forEach(item => {
                const dot = Math.abs(dragDir.dot(item.screenVec));
                if (dot > maxDot) {
                    maxDot = dot;
                    bestMatch = item;
                }
            });

            if (bestMatch) {
                const rotAxisVec = new THREE.Vector3().crossVectors(bestMatch.axis3D, worldNormal).normalize().round();
                
                let rotAxisChar = 'y';
                if (Math.abs(rotAxisVec.x) > 0.5) rotAxisChar = 'x';
                if (Math.abs(rotAxisVec.z) > 0.5) rotAxisChar = 'z';

                const pos = hit.object.position;
                let sliceVal = 0;
                if (rotAxisChar === 'x') sliceVal = Math.round(pos.x / TOTAL_SIZE);
                if (rotAxisChar === 'y') sliceVal = Math.round(pos.y / TOTAL_SIZE);
                if (rotAxisChar === 'z') sliceVal = Math.round(pos.z / TOTAL_SIZE);

                attachSliceToPivot(rotAxisChar, sliceVal);
                
                interactionState.axis = rotAxisChar;
                interactionState.slice = sliceVal;
                interactionState.screenAxis = bestMatch.screenVec; 
                interactionState.locked = true;

                const testPt = hit.point.clone();
                const rotVec = new THREE.Vector3();
                rotVec[rotAxisChar] = 1;
                testPt.applyAxisAngle(rotVec, 0.1);
                const p1 = hit.point.clone().project(camera);
                const p2 = testPt.project(camera);
                const screenMove = new THREE.Vector2(p2.x - p1.x, -(p2.y - p1.y));
                
                if (screenMove.dot(bestMatch.screenVec) < 0) {
                    interactionState.screenAxis.negate();
                }
            }
        }

        function attachSliceToPivot(axis, sliceIndex) {
            pivotGroup.rotation.set(0,0,0);
            pivotGroup.position.set(0,0,0);
            pivotGroup.updateMatrixWorld();

            const epsilon = 0.1;
            const activeCubies = cubies.filter(c => {
                let pos = c.position[axis];
                return Math.abs(pos - sliceIndex * TOTAL_SIZE) < epsilon;
            });

            activeCubies.forEach(c => {
                pivotGroup.attach(c);
            });
        }

        function onUp() {
            if (!interactionState.active) return;

            if (interactionState.locked) {
                const current = interactionState.currentAngle;
                const snapAngle = Math.round(current / (Math.PI/2)) * (Math.PI/2);
                snapAndFinish(interactionState.axis, snapAngle);
            }

            interactionState.active = false;
            controls.enabled = true;
            document.getElementById('canvas-container').className = 'cursor-grab';
        }

        function snapAndFinish(axis, targetAngle) {
            const startAngle = pivotGroup.rotation[axis];
            const startTime = Date.now();
            const duration = 150;

            function animateSnap() {
                const now = Date.now();
                const p = Math.min((now - startTime) / duration, 1);
                const ease = 1 - Math.pow(1 - p, 3);
                pivotGroup.rotation[axis] = startAngle + (targetAngle - startAngle) * ease;

                if (p < 1) {
                    requestAnimationFrame(animateSnap);
                } else {
                    pivotGroup.rotation[axis] = targetAngle;
                    pivotGroup.updateMatrixWorld();
                    
                    const children = [...pivotGroup.children];
                    children.forEach(c => {
                        scene.attach(c);
                        c.position.x = Math.round(c.position.x / TOTAL_SIZE) * TOTAL_SIZE;
                        c.position.y = Math.round(c.position.y / TOTAL_SIZE) * TOTAL_SIZE;
                        c.position.z = Math.round(c.position.z / TOTAL_SIZE) * TOTAL_SIZE;
                        c.rotation.x = Math.round(c.rotation.x / (Math.PI/2)) * (Math.PI/2);
                        c.rotation.y = Math.round(c.rotation.y / (Math.PI/2)) * (Math.PI/2);
                        c.rotation.z = Math.round(c.rotation.z / (Math.PI/2)) * (Math.PI/2);
                        c.updateMatrix();
                    });
                    
                    pivotGroup.rotation.set(0,0,0);

                    if (Math.abs(targetAngle) > 0.01) {
                        moveHistory.push({
                            axis: axis,
                            slice: interactionState.slice,
                            angle: targetAngle
                        });
                    }
                }
            }
            animateSnap();
        }

        async function autoSolveCube() {
            if (isSolving || interactionState.active) return;
            if (moveHistory.length === 0) return;

            isSolving = true;
            controls.enabled = false;

            while (moveHistory.length > 0) {
                const move = moveHistory.pop(); 
                await animateMove(move.axis, move.slice, -move.angle);
            }

            isSolving = false;
            controls.enabled = true;
        }

        function animateMove(axis, slice, angle) {
            return new Promise(resolve => {
                attachSliceToPivot(axis, slice);
                const startTime = Date.now();
                const duration = 150; 

                function loop() {
                    const now = Date.now();
                    const p = Math.min((now - startTime) / duration, 1);
                    const ease = 1 - Math.pow(1 - p, 3);
                    pivotGroup.rotation[axis] = angle * ease;

                    if (p < 1) {
                        requestAnimationFrame(loop);
                    } else {
                        pivotGroup.rotation[axis] = angle;
                        pivotGroup.updateMatrixWorld();
                        
                        const children = [...pivotGroup.children];
                        children.forEach(c => {
                            scene.attach(c);
                            c.position.x = Math.round(c.position.x / TOTAL_SIZE) * TOTAL_SIZE;
                            c.position.y = Math.round(c.position.y / TOTAL_SIZE) * TOTAL_SIZE;
                            c.position.z = Math.round(c.position.z / TOTAL_SIZE) * TOTAL_SIZE;
                            c.rotation.x = Math.round(c.rotation.x / (Math.PI/2)) * (Math.PI/2);
                            c.rotation.y = Math.round(c.rotation.y / (Math.PI/2)) * (Math.PI/2);
                            c.rotation.z = Math.round(c.rotation.z / (Math.PI/2)) * (Math.PI/2);
                            c.updateMatrix();
                        });
                        pivotGroup.rotation.set(0,0,0);
                        resolve();
                    }
                }
                loop();
            });
        }

        function scrambleCube() {
            if (isSolving || interactionState.active) return;
            const axes = ['x', 'y', 'z'];
            const slices = [-1, 0, 1];
            const dirs = [1, -1];
            
            isSolving = true; 
            const max = 15;

            async function runScramble() {
                for(let i=0; i<max; i++) {
                    const ax = axes[Math.floor(Math.random()*3)];
                    const sl = slices[Math.floor(Math.random()*3)];
                    const ang = dirs[Math.floor(Math.random()*2)] * (Math.PI/2);
                    
                    await animateMove(ax, sl, ang);
                    moveHistory.push({ axis: ax, slice: sl, angle: ang });
                }
                isSolving = false;
            }
            runScramble();
        }

        function updateCursor(cx, cy, buttons = 0) {
            mouse.x = (cx / window.innerWidth) * 2 - 1;
            mouse.y = -(cy / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cubies);
            
            const container = document.getElementById('canvas-container');
            if (intersects.length > 0) {
                container.className = 'cursor-pointer';
                if (buttons === 0) controls.enabled = false;
            }
            else {
                container.className = 'cursor-grab';
                if (buttons === 0) controls.enabled = true;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            controls.handleResize(); 
        }

        function setupKeyboardListeners() {
            window.addEventListener('keydown', (e) => {
                if(e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') keyState.w = true;
                if(e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') keyState.a = true;
                if(e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') keyState.s = true;
                if(e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') keyState.d = true;
            });
            window.addEventListener('keyup', (e) => {
                if(e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') keyState.w = false;
                if(e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') keyState.a = false;
                if(e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') keyState.s = false;
                if(e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') keyState.d = false;
            });
        }

        window.adjustView = function(dir) {
            const speed = 0.1;
            if (dir === 'left') rotateCameraFree(speed, 0);
            if (dir === 'right') rotateCameraFree(-speed, 0);
            if (dir === 'up') rotateCameraFree(0, speed);
            if (dir === 'down') rotateCameraFree(0, -speed);
        }

        function rotateCameraFree(azimuthDelta, polarDelta) {
            const offset = camera.position.clone().sub(controls.target);
            const up = camera.up.clone().normalize();
            const right = new THREE.Vector3().crossVectors(camera.up, offset).normalize();
            
            if (azimuthDelta !== 0) {
                offset.applyAxisAngle(up, azimuthDelta);
            }
            if (polarDelta !== 0) {
                offset.applyAxisAngle(right, polarDelta);
            }
            
            camera.position.copy(controls.target).add(offset);
            camera.lookAt(controls.target);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const rotateSpeed = 0.05;
            let isUsingKeys = false;

            if (keyState.a) { rotateCameraFree(rotateSpeed, 0); isUsingKeys = true; }
            if (keyState.d) { rotateCameraFree(-rotateSpeed, 0); isUsingKeys = true; }
            if (keyState.w) { rotateCameraFree(0, rotateSpeed); isUsingKeys = true; }
            if (keyState.s) { rotateCameraFree(0, -rotateSpeed); isUsingKeys = true; }

            // Only update TrackballControls if we are NOT using manual keys
            if (!isUsingKeys) {
                controls.update(); 
            }

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
